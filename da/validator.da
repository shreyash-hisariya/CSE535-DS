# validator
from collections import defaultdict
from collections import OrderedDict
import sys
import time
import da
import logging
from block_tree import Block_tree
from ledger import Ledger
from safety import Safety
from pacemaker import Pacemaker
from mempool import Mempool
from leader_election import Leader_election
from Models.proposal_message import ProposalMessage

class Validator(process):
    def setup(idx, validator_dict, n_validators, clients):
        self._idx = idx #redundant
        self._validator_dict = validator_dict
        self._n_validators = n_validators
        self.clients = clients

        self.round = 0
        self.leader = 0
        self.vote_msg = None
        self.tc = None
        self.qc = None
        self.u = idx
        self.b = None
        self.results = {}
        self.client_results = {}

        main_dict = {'round' : self.round, 'leader' : self.leader, 'vote_msg' : self.vote_msg, 'tc' : self.tc, 'qc' : self.qc, 'u' : self.u,
        'b' : self.b, 'results' : self.results, 'client_results' : self.client_results}
        validator_info={}
        validator_info['Main'] = main_dict
        file_name=str(self.u)+'_'+str("persistent_ledger_file.txt")

        self.mempool = Mempool(validator_info)
        validator_info['Mempool'] = self.mempool
        self.ledger = Ledger(defaultdict(),defaultdict(),OrderedDict(),file_name,{},validator_info)

        validator_info['Ledger'] = self.ledger
        self.block_tree = Block_tree({},{},None,None,validator_info)

        validator_info['BlockTree'] = self.block_tree
        self.safety = Safety('private_keys','public_keys',-1,-1,-1,validator_info)

        validator_info['Safety'] = self.safety
        self.pacemaker = Pacemaker(0,None,{},{},validator_info)

        validator_info['validator_dict'] = self._validator_dict # need to verify
        validator_info['Pacemaker']=self.pacemaker
        self.leader_election = Leader_election(validator_info)
        self.run_done = False
        self.curr_client = None

    def run():

        while not self.run_done:
            print(self.u,"SELF PC",self.pacemaker.last_round_tc)
            self.run_done = False
            timer_duration = self.pacemaker.get_round_timer(self.pacemaker.current_round)
            if await(len(self.client_results) > 0):
                output(' SENDING BACK TO CLIENT')
                for cmd in self.client_results.keys():
                    send(('RESULT_RESPONSE',(cmd, "SUCCESS")), to=clients)
                self.client_results.clear()
                self.run_done=False
            elif timeout(timer_duration) :
                timeout_message = self.pacemaker.local_timeout_round()
                print("BROAD CAST TIMEOUT MESSAGE FROM - ", self.u, " FOR ROUND - ", self.pacemaker.current_round)
                send(('TIMEOUT_MESSAGE', (self.u,timeout_message)), to=list(self._validator_dict.values()))
                break

        await(self.pacemaker.current_round > 7)


    def receive(msg=('CLIENT_REQUEST', request)):
        client, cmd, cid = request
        self.curr_client = client
        #if cmd in self.results.keys():
        #    output('RESULT CACHED FOR COMMAND - ', cmd, ' .RETURNING RESULT TO CLIENT - ', self.curr_client)
        #    send(('RESULT_RESPONSE',(cmd,self.results[cmd])),to=self.curr_client)
        #    return

        self.mempool.add_transaction(cmd,"PENDING")
        print(self.u,cmd," LAST ROUND TC ",self.pacemaker.last_round_tc, ' LEADER - ', self.leader_election.get_leader(self.pacemaker.current_round))
        if self.pacemaker.last_round_tc is not None:
            print("arey ",self.pacemaker.last_round_tc)
        self.process_new_round_event(self.pacemaker.last_round_tc,client,cmd)



    def receive(msg=('PROPOSAL_MESSAGE', m)):
        client, proposal_msg = m
        if (self.u == "v1" or self.u == "v2" or  self.u == "v4") and self.pacemaker.current_round==1 and proposal_msg.last_round_tc is None:
            time.sleep(3)
            return

        self.process_proposal_msg(client, proposal_msg)


    def receive(msg=('VOTE_MESSAGE',m)):
        validator_id, vote_msg = m
        self.process_vote_msg(validator_id, vote_msg)

    def receive(msg=('TIMEOUT_MESSAGE',m)):

        validator_id, timeout_msg = m
        if self.u=="v3" and self.pacemaker.current_round==1:
            #output("SELF ", self.u, "TIMEOUT_MESSAGE RECEIVED.", timeout_msg.tmo_info, " --- ", timeout_msg.tmo_info.block_round)
            self.process_timeout_msg(timeout_msg)


    def process_vote_msg(validator_id,M): #Function def changed to include validator_id

        #print(' RECEIVED VOTE MESSAGE FROM  - ', M.sender, ' FOR ROUND - ', M.vote_info.round, ' SELF - ', self.u)
        self.qc = self.block_tree.process_vote(M)
        if self.qc is not None:
            self.process_certificate_qc(self.qc)
            self.process_new_round_event(self.pacemaker.last_round_tc, None, None)

    def process_timeout_msg(M):
        #add code for decrypting timeout info (check page no 12)
        self.process_certificate_qc(M.tmo_info.high_qc)
        self.process_certificate_qc(M.high_commit_qc)
        self.pacemaker.advance_round_tc(M.last_round_tc)
        self.tc = self.pacemaker.process_remote_timeout(M)

        if self.tc is not None:
            output(' TC CREATED', self.u)
            self.pacemaker.advance_round_tc(self.tc) # need to verify
            self.process_new_round_event(self.tc,None,None)

    # v3 ne bheja none none for qc of qc
    def process_new_round_event(last_tc,client,M):  #Function def changed to include client

        if M is None or self.u == self.leader_election.get_leader(self.pacemaker.current_round):

            if M is not None:
                transaction=self.mempool.get_transactions()
                for t in transaction:
                    self.mempool.update_transaction(t,"PROCESSING")
                self.b = self.block_tree.generate_block(transaction, self.pacemaker.current_round)

            else:
               # print(' EMPTY QC ROUND BY - ', self.u, ' FOR ROUND - ', self.pacemaker.current_round)
                self.b = self.block_tree.generate_block([], self.pacemaker.current_round)

            # TO DO broadcast
            p = ProposalMessage(self.b, last_tc, self.block_tree.high_commit_qc, self.u)

            returnKeys=[]
            if M is None:
                sender_list=[]
                for k,v in self._validator_dict.items():
                    if k != self.u:
                        sender_list.append(v)
                        returnKeys.append(k)
                if last_tc is not None:
                    print(self.pacemaker.current_round,self.leader_election.get_leader(self.pacemaker.current_round),"1hello",self.u, " ",p.last_round_tc)

                send(('PROPOSAL_MESSAGE', (client, p)), to=sender_list)
            else:
                send(('PROPOSAL_MESSAGE', (client, p)), to=list(self._validator_dict.values()))



    def verify_signatures(block):
        hash_of_current_block=hash(block.author,block.block_round,block.payload,block.qc.vote_info.id,block.qc.signatures)
        if hash_of_current_block==block.block_id:
            return True
        return False


    def process_proposal_msg(client, P): #Function def changed to include client

        #if P is not None and P.block.payload is not None:
        #    output(' BLOCK PAYLOAD FOR c1-4', P.block.payload)

        #self.verify_signatures(P.block) #need to verify
        self.process_certificate_qc(P.block.qc)

        self.process_certificate_qc(P.high_commit_qc)
        self.pacemaker.advance_round_tc(P.last_round_tc)

        self.round = self.pacemaker.current_round
        self.leader = self.leader_election.get_leader(self.round) # need to verify

        if client is None or P.block.payload is None:
            #if P.last_round_tc is not None:
                #print(self.pacemaker.current_round,self.leader,"Wow",P.last_round_tc , " and   ",self.pacemaker.last_round_tc)
            #self.run_done = True
            return

        if P.block.round != self.round and P.sender != self.leader and P.block.author != self.leader:
            return

        self.block_tree.execute_and_insert(P.block)
        self.vote_msg = self.safety.make_vote(P.block, P.last_round_tc)

        if self.vote_msg is not None:
            for t in P.block.payload:
                self.mempool.update_transaction(t,"PROCESSING")

            send(('VOTE_MESSAGE', (self.u, self.vote_msg)), to=self._validator_dict[self.leader_election.get_leader(self.round+1)]) # need to verify


    def process_certificate_qc(qc):

        self.block_tree.process_qc(qc)     #do we need to broadcast the updated qc
        #output('DHDKAHDKHAKDHAKDHKADHKADHKAHDKAH')
        self.leader_election.update_leaders(qc) #do we need to broadcast the updated leader
        if qc is not None:
            self.pacemaker.advance_round_qc(qc)#need to verify

