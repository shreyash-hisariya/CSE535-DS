import sys
import time
import random
import validator as validator
#import client as client
from collections import OrderedDict

from nacl.signing import SigningKey
import json
import io

class Client(process):

    def setup(idx, client_id, validators, NOPS, client_delay_between_request):
        self.idx = idx
        self.client_id = client_id
        self.cid = 0           # command id
        self.results = dict()  # map of command id to result of command
        self.count = dict()    # map of command id to number of responses

    def run():
        cmds = []
        for i in range(NOPS):
            cmd = str(self.client_id) + " - " + str(i)
            send(('CLIENT_REQUEST', (self, cmd)), to=validators)
            time.sleep(client_delay_between_request)
            cid += 1
            cmds.append(cmd)
            self.count[cmd] = 0
        #await(each(cmd in cmds, has= self.count[cmd] == len(validators)))
        cnt = 0
        while(len(self.results) != NOPS and cnt < 3):
            cnt = cnt + 1
            for c in self.count.keys():
                if self.count[c] == 0:
                    #output(' SENDING AGAIN. SENDING AGAIN - ', c)
                    send(('CLIENT_REQUEST', (self, c)), to=validators)
                    time.sleep(client_delay_between_request)

        output(' COMING OUT OF WHILE - ', len(self.results))
        await(len(self.results) == (NOPS))
        output('terminating client - ', self.idx)
        send(('done',), to=parent())


    def receive(msg=('RESULT_RESPONSE', res)):
        cmd, status = res
        if cmd not in self.results:
            output(' RESPONSE RECEIVED FOR COMMAND - ', cmd)
            self.results[cmd] = status
        elif self.results[cmd] != status:
            error('different result', cmd, status, 'than', self.results[cmd])
        self.count[cmd] = self.count[cmd] + 1


def generateKeysForValidators(validator_ids):
    #signature_dict{
    #   "validators_public_key":{"specific_validator_id":validator_public_key}
    #   "private_key":value
    #   }

    #first generate signing_key for all the validators
    private_signing_keys=[SigningKey.generate() for i in range(0,len(validator_ids)) ]
    public_signing_keys={}
    for i in range(0,len(private_signing_keys)):
        public_signing_keys[validator_ids[i]]=private_signing_keys[i].verify_key.encode()

    #lets create signature_dict for all the validators
    list_signature_dict=[]
    for i in range(0,len(validator_ids)):
        signature_dict={}
        signature_dict["validators_public_key"]=public_signing_keys
        signature_dict["private_key"]=private_signing_keys[i]
        list_signature_dict.append(signature_dict)

    return list_signature_dict

def main():

    with open('config.json',encoding='utf-8-sig') as f:
        config = json.load(f)

    n_validators = config["number_of_validators"]
    n_clients = config["number_of_clients"]
    validator_ids=[]
    client_ids = []
    client_NOPS=config["workload_for_client"]["number_of_request"]
    client_delay_between_request=config["workload_for_client"]["delay_between_request"]

    for i in range(1,n_validators+1):
        validator_ids.append('v'+str(i))
    for i in range(1,n_clients+1):
        client_ids.append('c'+str(i))

    validators = list(new(validator.Validator, num= n_validators))
    clients = list(new(Client, num= n_clients))
    list_signature_dict=generateKeysForValidators(validator_ids)

    validator_dict = OrderedDict()
    for i in range(0, len(validator_ids)):
        id = validators[i]
        validator_dict[validator_ids[i]]=id

    client_dict = OrderedDict()
    for i in range(0, len(client_ids)):
        id = clients[i]
        client_dict[client_ids[i]]=id

    for i in range(n_validators):
       setup(validators[i], args=(validator_ids[i], validator_dict, n_validators, list_signature_dict[i], client_dict))

    for i in range(n_clients):
       setup(clients[i], args=(clients[i], client_ids[i], validators, client_NOPS, client_delay_between_request))
#       time.sleep(5)


    start(validators)
    start(clients)
#    for i in range(n_clients):
#        start(clients[i])
#        #time.sleep(5)

    await(each(c in clients, has=received(('done',), from_=c)))
    output('All clients done.')
    exit()
